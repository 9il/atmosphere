<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>atmosphere</title>
        </head><body>
        <h1>atmosphere</h1>
        <!-- Generated by Ddoc from source/atmosphere/package.d -->
<br><br>
<dl><dt><big><a name="MixtureOptimizer"></a>class <u>MixtureOptimizer</u>(T) if (isFloatingPoint!T);
</big></dt>
<dd><br><br>
<dl><dt><big><a name="MixtureOptimizer.components"></a>abstract const @property T[][] <u>components</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MixtureOptimizer.mixture"></a>abstract const @property const(T)[] <u>mixture</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MixtureOptimizer.distribution"></a>abstract const @property const(T)[] <u>distribution</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MixtureOptimizer.distribution"></a>abstract @property void <u>distribution</u>(in T[] <i>_distribution</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MixtureOptimizer.eval"></a>abstract void <u>eval</u>(scope bool delegate(T a, T b) nothrow @nogc <i>findRootTolerance</i> = null);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MixtureOptimizer.optimize"></a>void <u>optimize</u>(scope bool delegate(in T[] mixturePrev, in T[] mixture, in T[] distributionPrev, in T[] distribution) <i>tolerance</i>, scope bool delegate(T a, T b) nothrow @nogc <i>findRootTolerance</i> = null);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="MixtureOptimizer.optimize"></a>void <u>optimize</u>(scope T delegate(in T[] mixture) <i>objectiveFunction</i>, scope bool delegate(T objectiveFunctionValuePrev, T objectiveFunctionValue, in T[] distributionPrev, in T[] distribution) <i>tolerance</i>, scope bool delegate(T a, T b) nothrow @nogc <i>findRootTolerance</i> = null);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="StationaryOptimizer"></a>class <u>StationaryOptimizer</u>(T): MixtureOptimizer!T;
</big></dt>
<dd><br><br>
<dl><dt><big><a name="StationaryOptimizer.this"></a>this(size_t <i>k</i>, size_t <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StationaryOptimizer.components"></a>@property void <u>components</u>(in T[][] <i>_components</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="StationaryOptimizer.components"></a>@property void <u>components</u>(Kernels)(Kernels <i>kernels</i>, in T[] <i>grid</i>) if (isInputRange!Kernels &amp;&amp; hasLength!Kernels);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="GradientDescent"></a>class <u>GradientDescent</u>(alias Gradient, T): StationaryOptimizer!T;
</big></dt>
<dd><br><br>
<dl><dt><big><a name="GradientDescent.this"></a>this(size_t <i>k</i>, size_t <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureSeparator"></a>class <u>NormalVarianceMeanMixtureSeparator</u>(T): StationaryOptimizer!T;
</big></dt>
<dd><br><br>
<dl><dt><big><a name="NormalVarianceMeanMixtureSeparator.this"></a>this(in T[] <i>_grid</i>, in T[] <i>_sample</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureSeparator.alpha"></a>const @property T <u>alpha</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureSeparator.mean"></a>const @property T <u>mean</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureSeparator.sumOfLog2s"></a>const @property T <u>sumOfLog2s</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureSeparator.sample"></a>@property void <u>sample</u>(in T[] <i>_sample</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureSeparator.sample"></a>const @property const(T)[] <u>sample</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureSeparator.grid"></a>const @property const(T)[] <u>grid</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureSeparator.optimize"></a>void <u>optimize</u>(scope bool delegate(T alphaPrev, T alpha, T sumOfLog2sValuePrev, T sumOfLog2sValue, in T[] distributionPrev, in T[] distribution) <i>tolerance</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureEMSeparator"></a>class <u>NormalVarianceMeanMixtureEMSeparator</u>(T): NormalVarianceMeanMixtureSeparator!T;
</big></dt>
<dd><br><br>
<dl><dt><big><a name="NormalVarianceMeanMixtureEMSeparator.this"></a>this(in T[] <i>_grid</i>, in T[] <i>_sample</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureEMSeparator.eval"></a>void <u>eval</u>(scope bool delegate(T a, T b) nothrow @nogc <i>findRootTolerance</i> = null);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureEMAndGradientSeparator"></a>class <u>NormalVarianceMeanMixtureEMAndGradientSeparator</u>(T): NormalVarianceMeanMixtureSeparator!T;
</big></dt>
<dd><br><br>
<dl><dt><big><a name="NormalVarianceMeanMixtureEMAndGradientSeparator.this"></a>this(in T[] <i>_grid</i>, in T[] <i>_sample</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureEMAndGradientSeparator.eval"></a>void <u>eval</u>(scope bool delegate(T a, T b) nothrow @nogc <i>findRootTolerance</i> = null);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureEMAndCoordinateSeparator"></a>class <u>NormalVarianceMeanMixtureEMAndCoordinateSeparator</u>(T): NormalVarianceMeanMixtureSeparator!T;
</big></dt>
<dd>
<dl><dt><big><a name="NormalVarianceMeanMixtureEMAndCoordinateSeparator.this"></a>this(in T[] <i>_grid</i>, in T[] <i>_sample</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NormalVarianceMeanMixtureEMAndCoordinateSeparator.eval"></a>void <u>eval</u>(scope bool delegate(T a, T b) nothrow @nogc <i>findRootTolerance</i> = null);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="CoordinateDescent"></a>class <u>CoordinateDescent</u>(alias Gradient, T): StationaryOptimizer!T;
</big></dt>
<dd><br><br>
<dl><dt><big><a name="CoordinateDescent.this"></a>this(size_t <i>k</i>, size_t <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="CoordinateDescentPartial"></a>class <u>CoordinateDescentPartial</u>(alias PartialDerivative, T): StationaryOptimizer!T;
</big></dt>
<dd><br><br>
<dl><dt><big><a name="CoordinateDescentPartial.this"></a>this(size_t <i>k</i>, size_t <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="LikelihoodMaximizationCoordinate"></a>template <u>LikelihoodMaximizationCoordinate</u>(T)</big></dt>
<dd><pre class="d_code"><font color=blue>alias</font> <u>LikelihoodMaximizationCoordinate</u>(T) = CoordinateDescentPartial!(a =&gt; -1/a);
</pre>
<br><br>

</dd>
<dt><big><a name="LikelihoodMaximizationGradient"></a>template <u>LikelihoodMaximizationGradient</u>(T)</big></dt>
<dd><pre class="d_code"><font color=blue>alias</font> <u>LikelihoodMaximizationGradient</u>(T) = GradientDescent!((a, b) {<font color=blue>foreach</font>(i, ai; a) b[i] = -1/ai;});
</pre>
<br><br>

</dd>
<dt><big><a name="isCoordinateOprimization"></a>template <u>isCoordinateOprimization</u>(Class)</big></dt>
<dd>Returns <b>true</b> if Class use coordinate descend.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<u>isCoordinateOprimization</u>!(LikelihoodMaximizationCoordinate!<font color=blue>double</font>) == <font color=blue>true</font>);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isCoordinateOprimization</u>!(LikelihoodMaximizationGradient!<font color=blue>double</font>) == <font color=blue>false</font>);
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
